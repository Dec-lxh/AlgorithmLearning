## 概念

1. **GCD（最大公约数）**：
   - GCD（Greatest Common Divisor）是最大公约数，指的是两个或多个整数共有约数中最大的一个。
   - 在大多数情况下，我们更关注GCD，因为很多问题可以通过GCD来解决。
2. **LCM（最小公倍数）**：
   - LCM（Least Common Multiple）是最小公倍数，指的是两个或多个整数的公倍数中最小的一个。
   - 如果题目和LCM有关，也通常会转换成和GCD相关的。
3. **计算方法**：
   - GCD可以通过欧几里得辗转相除法得到。对于初学者来说，不必过于深究其原理，学会使用最重要。
   - LCM可以通过公式 `gcd(x, y) * lcm(x, y) = x * y` 来得到。
4. **C++中的函数**：
   - 实际上，C++已经准备好了计算GCD和LCM的函数，可以直接调用：
     - 函数分别是 `_gcd(a, b)` 和 `_lcm(a, b)`。

## 辗转相除法（也称为欧几里得算法）

计算两个整数的最大公约数（GCD）

```
int gcd(int a, int b)
{
    return b == 0 ? a : gcd(b, a % b);
}
```

代码解释：

- 函数 `gcd` 接受两个整数参数 `a` 和 `b`。
- 使用递归来计算GCD：
  - 如果 `b` 等于0，则返回 `a`，因为当第二个数为0时，GCD就是第一个数。
  - 否则，递归调用 `gcd(b, a % b)`，即用 `b` 和 `a` 除以 `b` 的余数作为新的一对数继续计算。

算法原理：

- 简单理解一下，首先不妨设 `a < b`，有 `gcd(a, b) = gcd(a, b-a) = gcd(a, b-2a) = ... = gcd(a, b % a)`。
- 由于 `b % a < a`，于是将 `a` 和 `b % a` 两个数调换位置，继续向下递归，直到 `b` 变为0。
- 当 `b` 变为0时，`gcd(x, 0) = x`，即GCD就是最后剩下的那个数。

示例：

- 例题：Lanqiao OJ 1260。

## 求最大公约数

利用了最大公约数（GCD）和最小公倍数（LCM）之间的关系，即 `lcm(a, b) = (a / gcd(a, b)) * b`，从而有效地计算两个数的最小公倍数

```
int lcm(int a, int b)
{
    return a / gcd(a, b) * b;
}
```

- 推荐先进行除法运算，再进行乘法运算，以避免在计算过程中发生整数溢出。
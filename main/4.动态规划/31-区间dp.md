## 区间DP的基本原理

1.区间DP的基本概念：定义状态的套路一般为到什么什么为止的最大价值或最小代价。 

2.区间DP的引入：当状态无法表示为从1开始时，需要引入区间DP。 

3.区间DP的定义：dp[i] [j]表示区间i到j的最大价值和最小代价。 

4.区间DP的推导：从较小的区间开始推导，逐步扩展到较大的区间。

## 区间DP的状态转移

1.状态转移方向：从小区间到大区间。 

2.转移顺序：先枚举区间大小，再枚举起点，最后确定终点。 

3.状态转移方程：
$$
DP[i][j] = min/max(DP[i][k] + DP[k+1][j])
$$
，其中k为区间i到j的分割点。

## 例题：Lanqiao OJ 1233 石子合并

## 例题：Lanqiao OJ 8342 小蓝吃苹果

![输入图片说明](https://cdn.jsdelivr.net/gh/Dec-lxh/Images@main/img/20250310104923.png)

1.初始化：将所有区间设为无穷。 

2.处理特殊情况：直接计算长度为1的区间。 

3.枚举长度和起点：从长度2开始枚举，再枚举起点和终点。 

4.状态转移：根据转移方程进行状态转移。 

5.输出：输出DP[1][n]

```
// 初始化
for(int i = 1; i <= n; ++ i)
    for(int j = i; j <= n; ++ j) dp[i][j] = inf;
// 特殊处理长度为1的
for(int i = 1; i <= n; ++ i) dp[i][i] = 1;
// 从长度为2开始枚举
for(int len = 2;len <= n; ++ len)
{
    // 枚举起点i
    for(int i = 1; i + len - 1 <= n; ++ i)
    {
        // 计算终点j
        int j = i + len - 1;
        // 状态转移
        if(a[i] == a[j]) dp[i][j] = min(dp[i][j], dp[i + 1][j - 1] + (len == 2));
        for(int k = i; k + 1 <= j; ++ k) dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]);
    }
}
cout << dp[1][n] << '\n';
```

## 例题：Lanqiao OJ 926 涂色

## 例题：Lanqiao OJ 1548 最小操作数
## 回溯法

### 简介

回溯法一般使用DFS（深度优先搜索）实现，DFS是一种遍历或搜索图、树或图像等数据结构的算法，当然这个图、树未必要存储下来（隐式处理就是回溯法），常见的是**通过某种关系构造出的搜索树**，搜索树一般是**排列型搜索树**（总节点个数一般为n!级别）和**子集型搜索树**（总节点个数一般为2^n级别）。

排列型就是**每次枚举选哪个**，子集型就是**对于每一个元素选或不选**（结果与顺序无关）。

DFS从起始节点开始，沿着一条路径**尽可能深入地搜索（一条路走到黑）**，直到无法继续为止，然后回溯到前一个节点，继续探索其他路径，直到遍历完整个图或树。

DFS使用栈或递归来管理节点的遍历顺序，一般使用**递归**。

很多时候DFS和回溯法**不必过度区分**。

### 排列树图解（1~3的全排列）

![image-20250208155105071](https://cdn.jsdelivr.net/gh/Dec-lxh/Images@main/img/20250310104606.png)

### 排列树图解（3个元素选或不选）

![image-20250208155236386](https://cdn.jsdelivr.net/gh/Dec-lxh/Images@main/img/20250310104609.png)

回溯算法能解决如下问题：

组合问题：N个数里面按一定规则找出k个数的集合
排列问题：N个数按一定规则全排列，有几种排列方式
切割问题：一个字符串按一定规则有几种切割方式
子集问题：一个N个数的集合里有多少符合条件的子集
棋盘问题：N皇后，解数独等等

回溯法确实不好理解，所以需要把回溯法抽象为一个图形来理解就容易多了，在后面的每一道回溯法的题目将遍历过程抽象为树形结构方便理解。

## 回溯法的模板

```
// 求1~n的全排列
int a[N];
bool vis[N];

void dfs(int dep)
{
    if(dep == n + 1)
    {
        for(int i = 1; i <= n; ++ i)cout << a[i] << ' ';
        cout << '\n';
        return;
    }
    for(int i = 1; i <= n; ++ i)
    {
        // 排除不合法的路径
        if(vis[i])continue;

        // 修改状态
        vis[i] = true;
        a[dep] = i;

        // 下一层
        dfs(dep + 1);

        // 恢复现场
        vis[i] = false;
        // a[dep] = 0 可以省略
    }
}
```

这是一个排列型搜索树，实际上的回溯法比较灵活，需要根据题意要求来具体分析。

`vis[i]`表示数字i是否使用过，也经常用于表示某个元素是否使用过。

`a[]`存放结果，当`dep`深度 = n + 1时说明n层都已经算完了，直接输出结果。

子集型搜索树模板结构类似，就是在往下走时候只有两条边，表示“选或不选当前这个元素
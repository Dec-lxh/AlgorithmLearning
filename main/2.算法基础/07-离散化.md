## 离散化简介

离散化是将无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。

离散化是一种将数组的值域压缩，从而更加关注元素的大小关系的算法。

当原数组中的数字很大、负数、小数时（大多数情况下是数字很大），难以将“元素值”表示为“数组下标”，一些依靠下标实现的算法和数据结构无法实现时，我们就可以考虑将其离散化。

例如原数组的范围是[1, 1e9]，而数组大小仅为1e5，那么说明元素值的“种类数”最多也就1e5种，从而可以利用一个数组（即离散化数组）来表示某个元素值的排名（即第几小），实现值域的压缩，将原数组的元素值作为下标来处理。

离散化数组要求内部是有序（一般是去重的，当然也存在不去重的方法，但是比较少见）的，可以直接通过离散化下标得到值，当然也可以通过值得到离散化下标（通过二分实现）。

例子：

| 原数组 a       | [不使用, 3, 1000, 2, 99999, 2] |
| -------------- | ------------------------------ |
| 离散化数组 *L* | [2, 3, 1000, 99999]            |
| 下标（index）  | [0, 1, 2, 3, 4, 5]             |

## 离散化的实现方法

```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int> L; // 离散化数组

// 返回x在L中的下标
int getidx(int x) {
    return lower_bound(L.begin(), L.end(), x) - L.begin();
}

const int N = 1e5 + 9;
int a[N];

int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> a[i];

    // 将元素存入L数组中
    for (int i = 1; i <= n; ++i) L.push_back(a[i]);

    // 排序去重
    sort(L.begin(), L.end());
    L.erase(unique(L.begin(), L.end()), L.end());

    return 0;
}
```

说明：

- 离散化的实现方法比较多样，但原理相同，这里采用 `vector` 来进行离散化